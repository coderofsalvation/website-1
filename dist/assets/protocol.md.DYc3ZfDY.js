import{_ as a,c as o,o as r,a4 as s,j as e,a as t}from"./chunks/framework.Bi9zwDUp.js";const i="/assets/webfinger-connect.D9I3dd-i.png",n="/assets/oauth-dialog.qL5q4qP8.png",c="/assets/screenshot-folder-description.CYwttkp4.png",I=JSON.parse('{"title":"The remoteStorage Protocol","description":"","frontmatter":{},"headers":[],"relativePath":"protocol.md","filePath":"protocol.md"}'),l={name:"protocol.md"},h=s('<h1 id="the-remotestorage-protocol" tabindex="-1">The remoteStorage Protocol <a class="header-anchor" href="#the-remotestorage-protocol" aria-label="Permalink to &quot;The remoteStorage Protocol&quot;">​</a></h1><p>remoteStorage is a creative combination of existing protocols and standards. It aims to re-use existing technologies as much as possible, adding just a small layer of standardization on top to facilitate its usage for per-user storage with simple permissions and offline-capable data sync.</p><h2 id="discovery-webfinger" tabindex="-1">Discovery: <a href="https://webfinger.net/" target="_blank" rel="noreferrer">WebFinger</a> <a class="header-anchor" href="#discovery-webfinger" aria-label="Permalink to &quot;Discovery: [WebFinger](https://webfinger.net/)&quot;">​</a></h2><p>In order for apps to know where to ask for permissions and sync data, you give them a user address, which looks the same as an email or XMPP address (and could be one, too). With that address, apps retrieve storage information for the username on that domain/host.</p><p><a href="https://client.webfinger.net/lookup?resource=tony%405apps.com" target="_blank" rel="noreferrer">Check out a live example for a 5apps user</a>.</p>',5),d=e("img",{src:i,role:"presentation"},null,-1),p=e("h2",{id:"authorization-oauth-2-0",tabindex:"-1"},[t("Authorization: "),e("a",{href:"https://oauth.net/",target:"_blank",rel:"noreferrer"},"OAuth 2.0"),t(),e("a",{class:"header-anchor",href:"#authorization-oauth-2-0","aria-label":'Permalink to "Authorization: [OAuth 2.0](https://oauth.net/)"'},"​")],-1),f=e("p",null,"User data is scoped by so-called categories, which are essentially base directories, for which you can give either read-only or read/write permission. Apps will use OAuth scopes to ask for access to one or more categories.",-1),_=e("p",null,[t("In this example screenshot, "),e("a",{href:"https://litewrite.net/",target:"_blank",rel:"noreferrer"},"Litewrite"),t(' is asking for read/write access to the "documents" category, using the OAuth scope '),e("code",null,"documents:rw"),t(". If you allow access, the app will retrieve a bearer token, with which it can read and write to your storage, until you revoke that access on your server.")],-1),u=e("img",{src:n,role:"presentation"},null,-1),g=e("h2",{id:"data-storage-sync-http-rest",tabindex:"-1"},[t("Data Storage & Sync: "),e("a",{href:"https://en.wikipedia.org/wiki/Representational_state_transfer",target:"_blank",rel:"noreferrer"},"HTTP REST"),t(),e("a",{class:"header-anchor",href:"#data-storage-sync-http-rest","aria-label":'Permalink to "Data Storage & Sync: [HTTP REST](https://en.wikipedia.org/wiki/Representational_state_transfer)"'},"​")],-1),m=e("p",null,"remoteStorage defines a simple key/value store for apps to save and retrieve data. The basic operations are GET/PUT/DELETE requests for specific files/documents.",-1),b=e("p",null,"In addition to that – and the only special feature aside from plain HTTP – there are directory listings, formatted as JSON-LD. They contain both the content type and size, as well as ETags, which can be used to implement sync mechanisms. The files and listings themselves also carry ETag headers for sync/caching and conditional requests.",-1),k=e("img",{src:c,role:"presentation"},null,-1),w=e("h2",{id:"specification",tabindex:"-1"},[t("Specification "),e("a",{class:"header-anchor",href:"#specification","aria-label":'Permalink to "Specification"'},"​")],-1),y=e("p",null,[t("Visit the "),e("a",{href:"https://datatracker.ietf.org/doc/html/draft-dejong-remotestorage",target:"_blank",rel:"noreferrer"},"IETF Datatracker"),t(" or "),e("a",{href:"https://github.com/remotestorage/spec",target:"_blank",rel:"noreferrer"},"GitHub"),t(" for the full protocol specification.")],-1),T=[h,d,p,f,_,u,g,m,b,k,w,y];function P(S,v,x,E,A,D){return r(),o("div",null,T)}const z=a(l,[["render",P]]);export{I as __pageData,z as default};
